<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

<meta charset="utf-8" />
<title>06</title>


<link rel="stylesheet" href="../../../style.css" type="text/css" />

<link rel="stylesheet" href="../../../local.css" type="text/css" />




<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/ikiwiki.cgi?do=edit&amp;page=archives%2F2016%2F06" />







</head>
<body>

<article class="page">

<section class="pageheader">
<header class="header">
<span>
<span class="parentlinks">

<a href="../../../">One may smile, and smile, and be a villain</a>/ 

<a href="../../../">archives</a>/ 

<a href="../">2016</a>/ 

</span>
<span class="title">
06

</span>
</span>



</header>


<nav class="actions">
<ul>

<li><a href="/ikiwiki.cgi?do=edit&amp;page=archives%2F2016%2F06" rel="nofollow">Edit</a></li>





<li><a href="/ikiwiki.cgi?do=prefs">Preferences</a></li>





</ul>
</nav>








</section>



<aside class="sidebar">


<div><div class="calendar"><table class="month-calendar">
    <tr>
    <th class="month-calendar-arrow"><a href="../05/" title="May">&larr;</a></th>
    <th class="month-calendar-head" colspan="5"><span class="selflink">Jun 2016</span></th>
    <th class="month-calendar-arrow"><a href="../07/" title="July">&rarr;</a></th>
    </tr>
    <tr>
        <th class="month-calendar-day-head Sunday" title="Sunday">S</th>
        <th class="month-calendar-day-head Monday" title="Monday">M</th>
        <th class="month-calendar-day-head Tuesday" title="Tuesday">T</th>
        <th class="month-calendar-day-head Wednesday" title="Wednesday">W</th>
        <th class="month-calendar-day-head Thursday" title="Thursday">T</th>
        <th class="month-calendar-day-head Friday" title="Friday">F</th>
        <th class="month-calendar-day-head Saturday" title="Saturday">S</th>
    </tr>
    <tr>
        <td class="month-calendar-day-noday Sunday">&nbsp;</td>
        <td class="month-calendar-day-noday Monday">&nbsp;</td>
        <td class="month-calendar-day-noday Tuesday">&nbsp;</td>
        <td class="month-calendar-day-nolink Wednesday">1</td>
        <td class="month-calendar-day-nolink Thursday">2</td>
        <td class="month-calendar-day-nolink Friday">3</td>
        <td class="month-calendar-day-nolink Saturday">4</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">5</td>
        <td class="month-calendar-day-nolink Monday">6</td>
        <td class="month-calendar-day-nolink Tuesday">7</td>
        <td class="month-calendar-day-nolink Wednesday">8</td>
        <td class="month-calendar-day-nolink Thursday">9</td>
        <td class="month-calendar-day-nolink Friday">10</td>
        <td class="month-calendar-day-nolink Saturday">11</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">12</td>
        <td class="month-calendar-day-nolink Monday">13</td>
        <td class="month-calendar-day-nolink Tuesday">14</td>
        <td class="month-calendar-day-nolink Wednesday">15</td>
        <td class="month-calendar-day-nolink Thursday">16</td>
        <td class="month-calendar-day-nolink Friday">17</td>
        <td class="month-calendar-day-nolink Saturday">18</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">19</td>
        <td class="month-calendar-day-nolink Monday">20</td>
        <td class="month-calendar-day-nolink Tuesday">21</td>
        <td class="month-calendar-day-nolink Wednesday">22</td>
        <td class="month-calendar-day-nolink Thursday">23</td>
        <td class="month-calendar-day-nolink Friday">24</td>
        <td class="month-calendar-day-nolink Saturday">25</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">26</td>
        <td class="month-calendar-day-link Monday"><div class="popup">27<div class="balloon"><ul>
            <li><a href="../../../posts/On Mining and Wallets/" title="On Mining and Wallets">On Mining and Wallets</a></li>
        </ul></div></div></td>
        <td class="month-calendar-day-nolink Tuesday">28</td>
        <td class="month-calendar-day-nolink Wednesday">29</td>
        <td class="month-calendar-day-this-day Thursday"><div class="popup">30<div class="balloon"><ul>
            <li><a href="../../../posts/ClassicQuality/" title="ClassicQuality">ClassicQuality</a></li>
        </ul></div></div></td>
        <td class="month-calendar-day-noday Friday">&nbsp;</td>
        <td class="month-calendar-day-noday Saturday">&nbsp;</td>
    </tr>
</table>
</div></div>


</aside>



<div id="pagebody">

<section id="content" role="main">


<article class="inlinepage">

<section class="inlineheader">
<header class="header">

<a href="../../../posts/On Mining and Wallets/">On Mining and Wallets</a>

</header>
</section>

<section class="inlinecontent">
<h3>Don't leave your money on the street.</h3>

<p>Bitcoind is labelled as the backend of the network. When I explain this to
friends I explain it like its the router that you have stuffed behind the
sofa or if you are more professional, in a server room, sometimes not even
in the same country you are in.
Either way, it is something needed for everything else to work. But mostly
ignored.</p>

<p>This is how I imagine the users of Bitcoin Classic to use the software, and
it is the way I think it should be. They use it as something that just
works to make it possible for them to keep their business or infrastructure
running.</p>

<p>One such group of Bitcoin Classic users are the miners, they run
bitcoin-classic to have an accurate view of the state of the network.  The
new transactions are collected in Bitcoin Classic and it creates new block
templates for them. In short; Bitcoin Classic helps miners connect to the
network.</p>

<p>What is totally out-of-character with the design that Bitcoin has had for
years is that, when the miner actually mines the block that the
block-reward is "stored" in the Bitcoin node.</p>

<p>This means that your Bitcoin Classic suddenly isn't just a piece of network
infrastructure anymore.  It holds thousands of dollars worth of value. And
because of that you'd have to protect it.  Which is not always compatible
with the way that you want to use a piece of network infrastructure.</p>

<p>See, the original Bitcoin node that Satoshi made was a reference client and
it included the ability to relay messages, it has a wallet and it knows how
to mine blocks.</p>

<p>Over the years we stopped using the mining software because other software
and hardware solutions have appeared that were much better.</p>

<p>We have also seen many better wallets which are much more used than a full
node based wallet.</p>

<p>All of those still use the bitcoin full node software, like Bitcoin
Classic, as a platform to build on.  They communicate via various channels
with the Bitcoin software which in turn connects them to the Bitcoin
Network.</p>

<p>It is in my opinion time to separate Bitcoin Mining from the Bitcoin
Wallet. We should no longer force Miners to use the Bitcoin wallet that is
shipped in Bitcoin Classic. We should no longer force the horrible security
practice of storing bitcoin private keys (and the money they represent) on
a piece of equipment that really is meant to be like a router or a hub
connecting your business to the Bitcoin network.</p>

<h3>Stop demanding a wallet in a mining node</h3>

<p>In Bitcoin Classic's development branch we have changed the
system to allow mining on a node that does not have a wallet compiled in.</p>

<p>I introduced a new RPC command called <code>createaddress</code>, which returns
something like this;</p>

<pre>
{
  "address": "1E852VpivAYpZcwGo5bNB9U4twjnJfrL2c",
  "pubkey":
"0303a60a215af3ea3240705db3201b5161445e1bdbd1e4e942284cfd9e9ede0ea1",
  "private": "KyjwYTJrhAS14fV7fP16Z9bhiudpPcSTT5HpPgpoampS57zgT59w"
}
</pre>


<p>The private key is the one piece of information needed to later spent the
money that would be stored on the address. To benefit from this change the
miner would store this private key in a secure location.</p>

<p>The pubkey and the address are not needed to be stored securely, they
can be used in future mined blocks.  When a block is mined with the pubkey
set, the money can later be redeemed using the safely stored private key.</p>

<p>A second new RPC command is <code>setcoinbase</code>.  When called with the 'pubkey'
field from above this will cause any following calls to
<code>getblocktemplate</code> to be generated so when it is mined all the fees and
block reward will go to the address.</p>

<p>People can use the output of <code>createaddress</code>, <strong>or if they don't like
change, just use the existing <code>getnewaddress</code> and <code>validateaddress</code> rpc
calls to create a coinbase that will end up in your bitcoind wallet</strong>.</p>

<p>Additionally the command-line option <code>--gencoinbase</code> is added to bitcoind
which has the same effect as the setcoinbase RPC command and that may be
useful to use until the mining software is upgraded to use these new RPC
commands. Because calling getblocktemplate without setting the coinbase
will now cause an error to be returned.</p>

<p>This change is still only available on the development branch, and has not
been scheduled for release just yet.  So <strong>there is still time to give
feedback on what you like or dislike or would like to change</strong>.</p>

<p>In my opinion these changes will have the positive effect that miners can
now feel much more safe when their bitcoind connects them to the bitcoin
network, without needing all the security that a full wallet should have.</p>

</section>

<footer class="inlinefooter">
<span class="readMore">

<a href="../../../posts/On Mining and Wallets/">Read full...</a>

</span>
<span class="pagedate">Posted <time datetime="2016-06-27T11:31:01Z" pubdate="pubdate">Mon 27 Jun 2016 11:31:01 AM Europe</time></span>


<nav class="tags">
Tags:

<a href="../../../tags/Bitcoin/" rel="tag">Bitcoin</a>

<a href="../../../tags/Mining/" rel="tag">Mining</a>

</nav>

</footer>
</article>
<article class="inlinepage">

<section class="inlineheader">
<header class="header">

<a href="../../../posts/ClassicQuality/">ClassicQuality</a>

</header>
</section>

<section class="inlinecontent">
<p>When I first started working with Bitcoin, a couple of years ago, I tried
to find out how to contribute code and to understand the Quality Assurance
policies they held.</p>

<p>At this time I naturally was talking to people from the Bitcoin Core group,
and the answers I got were quite confusing to me.</p>

<p>After having worked in the software industry for 20 years I had become very
reliant on good quality assurance policies. As well as good usage of
distributed source management control. Turns out that Core didn't really
have any of that in place.</p>

<p>When I was asked to work with Gavin on Bitcoin Classic I first started to
work on quality assurance policies and practices.  And I'm happy to say that
we have reached at least industry standard, if not a little above. But I
haste to say that there is still room for improvement.</p>

<h2>Git workflow</h2>

<p>The first thing that I changed is that we now have a proper git workflow.
This means that developers fix bugs on the stable branch and we use git
merges to make those bugfixes go up to the development branch.
You will find this process in any git book, so I wont' spent too much time
on this.  The important part is that merges between branches is done often
and that way we can't loose work or introduce bugs by doing it manually.
See also our <a href="https://github.com/bitcoinclassic/bitcoinclassic/blob/develop/CONTRIBUTING.md">contributing
document</a>.</p>

<h2>Release process</h2>

<p>The second part that changed is the release process itself.
Based on the fact that we now have a stable branch that is always
releasable the release process will become easier.  The aim is to follow
the good old open source concept of "Release early, release often".</p>

<p>One of the biggest changes is that we now follow the <a href="http://semver.org/">Semantic
Versioning</a> concept which is almost universal for open
source software as well as for many closed source products.</p>

<p>Let me quote the core concept;</p>

<blockquote><p>Given a version number MAJOR.MINOR.PATCH, increment the:</p>

<ol>
<li>MAJOR version when you make incompatible API changes,</li>
<li>MINOR version when you add functionality in a backwards-compatible
manner, and</li>
<li>PATCH version when you make backwards-compatible bug fixes.</li>
</ol>
</blockquote>

<p>Additionally I wrote this in the release tag of v1.1.0</p>

<p>At first we wanted to follow the Core releases, but they have different
core-values and push out hundreds of lines of new code in a bugfix release
which feels dirty to have to inherit.  The result of that is that the CSV
soft fork code feature release has received a bigger version bump.  And
when that disconnect between Core and Classic versions it also stopped
making sense to stay close to versioning of Core.<br />
It was time to review the numbering scheme altogether.</p>

<p>When I talked about the "less than 1.0" versioning over beers with
<a href="https://en.wikipedia.org/wiki/Eric%5FS%2E%5FRaymond">Eric S. Raymond</a> (author of <a href="https://en.wikipedia.org/wiki/The%5FCathedral%5Fand%5Fthe%5FBazaar">The Cathedral and the Bazaar</a>) he explained it like this:<br />
The idea was that when the app reaches the set of features required
for the user with the lowest demands to use it for its intended usage,
that's when you call it 1.0.</p>

<p>Bottom line, Bitcoin is certainly far past its 1.0 release. We will follow
the Semantic Versioning from now on.</p>

<h2>Continues Integration building</h2>

<p>What I was really missing was a proper <a href="https://en.wikipedia.org/wiki/Continuous%5Fintegration">Continuous integration</a> (CI) system. Naturally, there is the freely
available Travis.  But thats been a frustrating experience and really not
useful as a build server. Apart from the fact that Travis is really slow
(taking an hour or more), some and 60% of the time when it says there is a
failure, it actually isn't a problem in our code, its really not useful to
rely on.</p>

<p>I got a dedicated server in a secure environment and installed Teamcity on
it. Teamcity is one of the most used CI software systems out there and
quite useful for our purposes.</p>

<p><a href="../../../images/teamcity.png"><img src="../../../posts/ClassicQuality/500x500-teamcity.png" width="500" height="463" class="float-right" /></a></p>

<p>It does a couple of things;</p>

<ol>
<li>every single time a change is made in Git (in all branches) it builds
this for all platforms and runs unit tests at least for the Linux ones.
Notice that it does the building in a fraction of the time that Travis
took. Typically a build completes in less than 15 min.</li>
<li>It builds both using the 'gitian' concept of reproducible (or static)
build environment for all platforms as well as using the native Linux way
of using the platform dynamic-libraries (dlls). This makes sure we know it
works on more than one version of boost and all the other supporting
libraries.</li>
<li>It builds nightly builds of the development branch allowing people to
test these that don't want to compile.</li>
<li>It pushes the build to remote builders (like Ubuntu's launchpad) to have
an easy way to distribute nightly builds or maybe even future releases with
minimum effort.</li>
<li>It tests the Debian contrib to actually build properly.</li>
</ol>


<p>As I mentioned, the server is in a secure location. What that means is that
it is not connected to the internet and physically protected to make sure
we can trust the output of that server.  When we ship sources anyone can
check quickly if they are unaltered from the tags in git. But with binaries
(evil) changes can be much harder to detect.  So I refuse to gpg-sign any
releases unless I know they actually came from the exact sources that are
in git, visible for all.</p>

<h2>Ongoing work</h2>

<p>There is plenty of issues that could use improvements.  It turns out that
the original developers don't really like writing unit tests and the code
lacks any organization to make unit testing practical or easy.  With some
small changes such efforts could be made much easier.</p>

<p>We also have exactly one executable that runs all the test. Which is
against the unit testing practices of having small units because one
failure in one test can cause a lot of tests afterwards to start failing
too, mostly because the memory states were not cleaned up properly after a
failure.</p>

<p>Ideally we have a lot of small test executables which can be run by a
simple runner. With the added benefit that you can run various in parallel
(one per cpu-core) which makes the whole complete much faster as well.</p>

<p>We currently have a benchmark framework, but nothing in there. The idea of
a benchmark is that code which is time critical can be tested in there and
the output can be printed and plotted over a long time (months) to see that
such time critical code doesn't get slower by unintended changes from
release to release.<br />
I find it hard to believe that Bitcoin has no time critical code, as such
we should be able to find value to locate, test and keep code from getting
slower.</p>

<p>Better integration Linux distro's. Bitcoin was made to be shipped as a big
executable with all the libraries inside. The thinking was that this saves
the application from misbehaving when another library changes behavior.
While the idea seems logical, it shows a lack of experience because the
open source community has been solving this problem for 30 years and it
does so quite successfully.  Going against that only introduces a different
set of problems.  For instance when the libc DNS exploit was made public
Bitcoin dodged a bullet because libc is one of the very few libraries we
don't actually compile in. But imagine any of the libraries we include has
such a similar vulnerability and the only way to solve that is to re-build
Bitcoin and get everyone to manually update.   The Linux alternative of
just running an <code>apt-get upgrade</code> or similar is vastly more secure and
better supported.</p>

<p>As mentioned in the CI section, I already added support for Classic in
launchpad. This may be something to expand upon and support more Linux
distros in a similar fashion.</p>

<h2>Conclusion</h2>

<p>Bitcoin Classic has a strong Quality Assurance policy, adopts long time
industry standard practices and sheds unsafe self-invented ones from
upstream.</p>

<p>We also take all the best practices from Open Source and Free Software to
make releases often for those that want to test the latest and contribute
by reporting issues, or simply by being part of the network.</p>

<p>The future is bright!</p>

</section>

<footer class="inlinefooter">
<span class="readMore">

<a href="../../../posts/ClassicQuality/">Read full...</a>

</span>
<span class="pagedate">Posted <time datetime="2016-06-30T10:33:56Z" pubdate="pubdate">Thu 30 Jun 2016 10:33:56 AM Europe</time></span>


<nav class="tags">
Tags:

<a href="../../../tags/Bitcoin/" rel="tag">Bitcoin</a>

</nav>

</footer>
</article>





</section>







</div>

<footer id="footer" class="pagefooter" role="contentinfo">

<nav id="pageinfo">





<div class="copyrightinfo">
Copyright &copy; 2016 Tom Zander &lt;tomz@freedommail.ch&gt;</br>
Content licensed under the <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC by-sa</a>
</div>

<div class="pagedate">
Last edited <time datetime="2016-06-30T10:57:09Z">Thu 30 Jun 2016 10:57:09 AM Europe</time>
</div>

</nav>


</footer>
</article>

</body>
</html>
