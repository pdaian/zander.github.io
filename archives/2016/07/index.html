<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

<meta charset="utf-8" />
<title>07</title>


<link rel="stylesheet" href="../../../style.css" type="text/css" />

<link rel="stylesheet" href="../../../local.css" type="text/css" />










</head>
<body>

<article class="page">

<section class="pageheader">
<header class="header">
<span>
<span class="parentlinks">

<a href="../../../">Toms place</a>/ 

<a href="../../../">archives</a>/ 

<a href="../">2016</a>/ 

</span>
<span class="title">
07

</span>
</span>



</header>


<nav class="actions">
<ul>





<li><a href="/ikiwiki.cgi?do=prefs">Preferences</a></li>





</ul>
</nav>








</section>



<aside class="sidebar">
<div><div class="calendar"><table class="month-calendar">
    <tr>
    <th class="month-calendar-arrow"><a href="../06/" title="June">&larr;</a></th>
    <th class="month-calendar-head" colspan="5"><span class="selflink">Jul 2016</span></th>
    <th class="month-calendar-arrow"><a href="../08/" title="August">&rarr;</a></th>
    </tr>
    <tr>
        <th class="month-calendar-day-head Sunday" title="Sunday">S</th>
        <th class="month-calendar-day-head Monday" title="Monday">M</th>
        <th class="month-calendar-day-head Tuesday" title="Tuesday">T</th>
        <th class="month-calendar-day-head Wednesday" title="Wednesday">W</th>
        <th class="month-calendar-day-head Thursday" title="Thursday">T</th>
        <th class="month-calendar-day-head Friday" title="Friday">F</th>
        <th class="month-calendar-day-head Saturday" title="Saturday">S</th>
    </tr>
    <tr>
        <td class="month-calendar-day-noday Sunday">&nbsp;</td>
        <td class="month-calendar-day-noday Monday">&nbsp;</td>
        <td class="month-calendar-day-noday Tuesday">&nbsp;</td>
        <td class="month-calendar-day-noday Wednesday">&nbsp;</td>
        <td class="month-calendar-day-noday Thursday">&nbsp;</td>
        <td class="month-calendar-day-nolink Friday">1</td>
        <td class="month-calendar-day-nolink Saturday">2</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">3</td>
        <td class="month-calendar-day-link Monday"><div class='popup'>4<div class='balloon'><ul>
            <li><a href="../../../posts/Innovation - OnlineScaling/" title="Innovation - OnlineScaling">Innovation - OnlineScaling</a></li>
        </ul></div></div></td>
        <td class="month-calendar-day-nolink Tuesday">5</td>
        <td class="month-calendar-day-nolink Wednesday">6</td>
        <td class="month-calendar-day-nolink Thursday">7</td>
        <td class="month-calendar-day-nolink Friday">8</td>
        <td class="month-calendar-day-nolink Saturday">9</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">10</td>
        <td class="month-calendar-day-this-day Monday"><div class='popup'>11<div class='balloon'><ul>
            <li><a href="../../../posts/Scaling Bitcoin/" title="Scaling Bitcoin">Scaling Bitcoin</a></li>
        </ul></div></div></td>
        <td class="month-calendar-day-future Tuesday">12</td>
        <td class="month-calendar-day-nolink Wednesday">13</td>
        <td class="month-calendar-day-nolink Thursday">14</td>
        <td class="month-calendar-day-nolink Friday">15</td>
        <td class="month-calendar-day-nolink Saturday">16</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">17</td>
        <td class="month-calendar-day-nolink Monday">18</td>
        <td class="month-calendar-day-nolink Tuesday">19</td>
        <td class="month-calendar-day-nolink Wednesday">20</td>
        <td class="month-calendar-day-nolink Thursday">21</td>
        <td class="month-calendar-day-nolink Friday">22</td>
        <td class="month-calendar-day-nolink Saturday">23</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">24</td>
        <td class="month-calendar-day-nolink Monday">25</td>
        <td class="month-calendar-day-nolink Tuesday">26</td>
        <td class="month-calendar-day-nolink Wednesday">27</td>
        <td class="month-calendar-day-nolink Thursday">28</td>
        <td class="month-calendar-day-nolink Friday">29</td>
        <td class="month-calendar-day-nolink Saturday">30</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">31</td>
        <td class="month-calendar-day-noday Monday">&nbsp;</td>
        <td class="month-calendar-day-noday Tuesday">&nbsp;</td>
        <td class="month-calendar-day-noday Wednesday">&nbsp;</td>
        <td class="month-calendar-day-noday Thursday">&nbsp;</td>
        <td class="month-calendar-day-noday Friday">&nbsp;</td>
        <td class="month-calendar-day-noday Saturday">&nbsp;</td>
    </tr>
</table>
</div></div>

</aside>



<div id="pagebody">

<section id="content" role="main">
<article class="inlinepage">

<section class="inlineheader">
<header class="header">

<a href="../../../posts/Innovation - OnlineScaling/">Innovation - OnlineScaling</a>

</header>
</section>

<section class="inlinecontent">
<p>Last weekend we had the On-chain scaling conference which was a big success
with lots of excellent speakers and a large amount of visitors asking
questions and showing interest.</p>

<p>I understand that a lot of people didn't manage to see them live for
various reasons. Not the least of them being time-zone differences.</p>

<p>When my talk went onto YouTube I decided to put up a transcript here.
The actual talk can be found on <a href="https://youtu.be/TCj84RKdjTs">youtube</a>.</p>

<h2 id="transcript">Transcript</h2>

<p>About 10 years ago I worked at Trolltech, a small Norwegian company making
tools for developers to build beautiful applications. I worked there for
some years when we got acquired by Nokia.
Nokia wanted our development libraries to work fast and smooth on their
phones as well as on traditional desktops.</p>

<p>As this was a developer-driven company many developers came up with
solutions on how to reach that goal.  These developers showing off their
ideas meant we had lots of awesome projects to chose from. The projects can
roughly be split into 2 sides.   The "optimization" side which easily
fixes a hundred little speed problems . And a "Big-Changes" side.  These are
projects that require much more time because they change some fundamental
ideas, but they also have a lot larger return on investment.</p>

<p>I would argue that Bitcoin is in the same position now.  We <em>have</em> to get
better and we have to scale Bitcoin for many more expected users coming
in over the next years.</p>

<p>My experience with this process in Trolltech was that all the small,
low-risk changes to make it faster were a huge success. They were needed,
and they made a huge difference.</p>

<p>On the other hand, the larger "Big-Changes" inevitably introduced more risk and
they forced people using our software to change their behavior to actually
use the new concepts and ideas.
For those reasons their effort ended up taking several years to bear fruit.</p>

<p>In the end both groups pulled it off, and the results are in
my personal opinion simply unique and amazing.</p>

<p>Some lessons I learned from those projects at Trolltech are;</p>

<ul>
<li><p>we need researchers to do what they do best. Come up with strange and
exciting ways to do things better.</p></li>
<li><p>we also need people doing the boring, "optimization" work, making
networking protocols work faster and more reliably as a simple example.</p></li>
</ul>

<p>This conference presents various "optimization-level" changes that will make
Bitcoin scale much better than it does now. With very little pain, and from
experience I expect quite a big gain.
We call this <em>on-chain</em> scaling, because whatever your belief is on
which path leads to Bitcoins success, if we want to scale, we need on-chain
transactions to scale beyond the current 3 transactions per second.</p>

<p>For the next years some changes are being prepared which
by the nature of them being fundamental changes
in the way that Bitcoin will end up being used, will take much longer to create and rollout.  I've
seen plans like Segregated Witness and the Lightning Network, interesting
ideas, for sure.  Various teams are working on that and I wish them all the
luck. It is already clear that we can't expect those scaling solutions to have
any reasonable impact without on-chain scaling solutions being rolled out
as well.</p>

<p>This makes sense off-course, when you think about it, you need the
foundation to be strong when building on top of it.</p>

<h2 id="bitcoininanutshell">Bitcoin, in a nutshell</h2>

<p>Now, enough with the high level talk, lets see some actual ideas.</p>

<p><a href="../../../images/presentation-onchain1.gif"><img src="../../../images/presentation-onchain1.gif" width="400" height="224" class="img" /></a></p>

<p>This is the idea of Bitcoin.
We have a single computer that receives transactions and groups them all in
its memory pool.  What it does at the same time is Bitcoin checks each of
those transactions for validity and after some time those transactions are
combined into a block.</p>

<p>Every single transaction entering this Bitcoin computer is checked that the
transaction is a legal one.  For instance, a payment from person A to
person B can only be created by person A. We use cryptographic proof to
check that the person initiating the transaction is actually the owner of
the coins he or she he sending.</p>

<p>Bitcoin also checks that people don't try to send the digital coins to two
people at the same time.  The Bitcoin application holds all transactions in
storage and if one comes in that tries to spend already spent money, it is
simply rejected.</p>

<p>When a block comes in it makes the transactions contained in that block
permanent and Bitcoin will merge that block into its database.
The transactions it had in memory are now removed if they were already in
the block, or no longer valid because of other transactions in the block.</p>

<p><a href="../../../images/presentation-onchain2.gif"><img src="../../../images/presentation-onchain2.gif" width="400" height="224" class="img" /></a></p>

<p>Bitcoin is essentially fully operational with just one node, but it works
with duplication of its functionality over different nodes. Here on screen
are 5 nodes.</p>

<p>When a transaction comes in, the node validates it and if its valid the node
will forward it to all its neighbors. Which do the same and forward it to
their neighbors.  In less than 1 second 50% of the network will have the
transaction, in less than 4s practically all of them will have it.</p>

<p>These nodes are in many respects exact duplicates, so technically there is
little reason to have more than one node, except maybe failover.
Politically this duplication means we avoid centralized decision making. We
avoid one operator being able to tell the rest of the world what Bitcoin
will look like today. This is assuming we make the system work fast enough.</p>

<p><a href="../../../images/presentation-onchain3.gif"><img src="../../../images/presentation-onchain3.gif" width="400" height="224" class="img" /></a></p>

<p>Blocks, the big collections of transactions, get copied between nodes as
well. The propagation path is similar to transactions.  Currently we send
blocks as a complete chunk of data in one go. This is then validated by a
node to follow the Bitcoin rules and forwarded to its neighbors.</p>

<p>A healthy network has a large number of Bitcoin nodes to ensure operation
and to allow some of them to be removed without harming Bitcoin as a
whole. Damage to any part of the network will just get routed around.</p>

<p>Naturally, with a large number of nodes, how they are networked together
becomes more important and that networking layer itself becomes a source of
failure.</p>

<p>What I've skipped over so far is where the blocks come from. A block is
created by a miner.
See, here is one in the bottom left corner.</p>

<p>It creates a block and sends it over the network.
Each node turning blue means they received the data.</p>

<p>Now, because a block is actually a substantial amount of
data, it will take longer than the one second that a single transaction
took.</p>

<p><a href="../../../images/presentation-onchain4.gif"><img src="../../../images/presentation-onchain4.gif" width="400" height="224" class="img" /></a></p>

<p>Bitcoinstats.com reports between 10 seconds and a minute to propagate a 1MB
block to practically the whole network.</p>

<p>If we start making bigger blocks, this time will go up. More data means slower
propagation times.</p>

<p>As the mining difficulty is adjusted every 2 weeks to  make sure that the
time between blocks stays on average 10 minutes, the time it takes to send
an entire block is not a big deal for end users. As long as they can
download blocks faster than they get created, things will continue working.
Not optimally, but it works.</p>

<p>There are many people using Bitcoin that have higher requirements than
that, though, and the
current way that Bitcoin works leaves a lot of space for improvement.</p>

<h2 id="howdoesthisworkforminers">How does this work for miners?</h2>

<p><a href="../../../images/presentation-onchain5.png"><img src="../../../posts/Innovation - OnlineScaling/400x325-presentation-onchain5.png" width="400" height="325" class="float-right" /></a></p>

<p>I'm currently focussing on miners. How to make sure that miners get the
best out of the system. To explain what I'm working on I will first show
what happens with miners using the Bitcoin software.</p>

<p>I'm going to draw the time as shown from the perspective of two miners. One
at the top of the screen, and another miner in another physical location at
the bottom of the screen.</p>

<p>Two miners are mining and one finds a nonce that makes his block valid.
So this miner is happy, he just made several thousands of dollars worth of
money. At least, as long as he can convince the rest of the world to use
this block he just completed to build on top off for following Bitcoin
blocks.  This implies his block is seen by the rest of the network before
any competitors block have finished their block.</p>

<p>To do so, he sends this block over the network to another miner.
The mean propagation time measured by Peter Rizun for blocks between 900kb
and 1MB shows about 4 seconds, but as soon as you hop over the great
firewall of China this rises to a mean of 17.4 seconds.  I'll use the
real-time example of 10 seconds here mostly because I don't talk so fast
anyway.</p>

<p>Now, after the miner on the bottom received the block, he will be able to
start mining on top of that.</p>

<p>What you may notice is that the miner on the bottom is essentially doing
work for about 10 seconds that is useless. He was still competing in the
competition for block 1 while that race has already been won by another.
He just didn't know that yet.</p>

<p>Lets take a look at my proposal using "Optimistic mining", which tries to
fix this specific little issue.</p>

<p>Same situation, one miner finds a block.  Here is a difference. I split up the block into two parts, one is teeny
tiny and send over the network in close to the speed of light and the other
is the actual block, unchanged from before.</p>

<p>While the entire block is being sent, the miner at the bottom is now all of a
sudden able to mine on top of this new block. Therefore no longer losing money
doing work that is useless.
Because the full block with all the transactions hasn't arrived yet he
can't know which transactions were included in it, and thus which
transactions he can safely include in his block. The solution to this is
for his block to be empty.</p>

<p>The miner switches to mining a full block as soon as he received the whole
block with transactions and is able to decide which transactions to
include in his block.</p>

<p>The 10 seconds highlighted here is the propagation time of a full block.
This time can be influenced by many things. Bigger blocks can make it take
longer. Network attacks may make it essential to ask the original miner for
more details, slowing down the propagation time. And most importantly, as
we currently see with the great-firewall of china, some countries may just
not have such a great connection to the rest of the world.  I don't think
its a good idea that a miner in Australia loses money just because he has a
slower connection to the rest of the world.</p>

<p>Optimistic mining means a miner is made immune to any propagation delays of
the transactions in a block. This only can mean good things to avoid
centralization of mining power.</p>

<p>In my designs the teeny-tiny part of the block a miner sends out as soon as
he finds a block will be just a block header making it approximately 100 bytes.
A node can validate this with a cheap check and then forward it.</p>

<p>Two details are important here; the data is forwarded by any node to
its peers and thats it.  There is no more network traffic that a peer
generates based on this.  It is just a way to broadcast a new piece of data
as fast as possible, as far as possible.</p>

<p>As I promised, these changes are mostly boring and really not
noble price worthy. I still get excited from changes that have a
substantial benefit, though. But I'm just that kind of geek.
These changes do help a lot when you add many of them together and
end up with a massively better scaling system than what we have today.</p>

<h2 id="whattoworkonnext">What to work on next</h2>

<p>If we look at what it means to scale Bitcoin today we look at all the
obvious resources that any computer program needs. Most of them are really
not an issue. For instance it would take 75 years to fill up a mainstream
harddrive of 3TB with todays block size.  People run the client on a
raspberry Pi. And it copes just fine.</p>

<p>In Bitcoin the biggest scaling issue we have today is the inefficient use
of bandwidth and the poor peer to peer network.  This is demonstrated best
by the usage of a centralized relay system which operates outside of the
Bitcoin network that miners use to send blocks to each other as fast as possible.
As long as those centralizes systems are needed we will have a permissioned
system where a new player needs permission to enter.  New player that don't
get permission to use the relay system that all the other miners are on,
will not be able to compete.
We don't want a system where the relay operators get to decide what miners
can and can not do, under threat of losing their access and subsequently
their business.</p>

<p>In Bitcoin we currently have what I'd label a first generation p2p network.
Think about a system that students typically set up in class during
computer science as a play thing. Its making all the traditional mistakes.</p>

<h2 id="furtherresearch">Further research</h2>

<p>The Bitcoin network uses unlabeled binary blobs to send over the wire. This
implies that developers can never fix a message because old clients would
not understand it and likely fail spectacularly.  Tagged formats, the most
well known of which is JSON, solved this many years ago.
What we need is like HTML where an old browser can still read the
newest format without giving errors. It just ignores the parts it doesn't
know.</p>

<p>When I worked for a financial company sending out half a million stock-price
quotes every second, I learned a lot about how to do a binary protocol
properly.
I've done some extended testing already with a new on-the-wire protocol that
has looks like its saving on bandwidth and speed quite substantially.
But the real benefit is that it can be extended because the fields are
labeled much like JSON or XML do. Its values are also strongly typed and
extensible.  What that means is that the protocol itself includes the
information that says a value is an int, a bool or a string.</p>

<p>Making such a chance would be very beneficial to make the protocol more
maintainable by allowing bugfixes to be made that are backwards compatible
in a clean manner.</p>

<p>Another issue we have with our peer to peer system is based on how an
individual node finds other nodes to connect to. We have some code
that decides based on the IP-address numbers whom to connect to.
The logic seems to be
that an IP address is a good indication for location, so it searches to
connect to many different locations.
Unfortunately, this is overstating the correlation between addresses and
distance so this is only slightly better than pure randomly choosing whom to
connect to.</p>

<p>Why is this important? Lets take an example of 2000 nodes, all around the world that
want to get a message as fast as possible to all of those nodes,
my thinking is that we each node should measure the distance to another
node by seeing how long it takes to send a message and the message to come
back to us.</p>

<p>We can then order the
sending of the messages so longer distance messages are send first and
shorter distance messages are send later.</p>

<p>Think about it like this, you could send a message by courier to the next
village and he sends it to the next and so on.
Or you send a courier by plane to the next big city and he starts sending
couriers out from there.
The idea is that a message would get to the the other side of the globe in
5 hops instead of 50.</p>

<p>To be fair, there are really not a lot of systems out there that create a
peer to peer system of this scale that have no central server and have to
send messages through the entire system as fast as possible. But this lack of
competition just means its going to be a nice challenge to find what works
and what doesn't.</p>

<h2 id="someotherdetails">Some other details</h2>

<p>We have some work done that fixes the problem that while downloading and
validating a block that node can't relay transactions.</p>

<p>For our protocol to get to a more professional level we'd also need message
priority. A node pushing something to the top of the message-queue to be sent.</p>

<p>We'd likely want to support both TCP and UDP queues where UDP is used for
higher-priority but smaller messages.  That would be ideal for the
optimistic mining teeny-tiny block message we want to go around the world in
near lightspeed.</p>

<p>And last we'd <em>really</em> need to set a maximum size for a single message. The
telco's switched to packet switching in the 90s, we're long overdue.
We now send a single message of one or many megabytes, experience shows that
splitting that up into multiple messages or maybe 50kb, and re-assembling it on the other
side will have a very positive effect on throughput because you can
send bigger data to two peers at the same time, using only twice the wall-time in optimal situations.
But when you are sending a large block to a peer
that is very slow in receiving it, this message chunk-ING will stop slowing
down your sending speed to another peer at the same time.</p>

<p>I've implemented this in another system where the overhead per 50KB message ended
up being only 14 bytes. So I really don't see any reason to not do this.</p>

<p>These are useful changes that I'm hoping to see being worked on, if not by
me, then someone else.</p>

<p>Other issues we will bump into as we get bigger blocks and higher
throughput are going to be found, and fixed as we move forward. I have no
doubt about that. That is the nature of this game, there is always some
optimization that we haven't done yet.</p>

<p>Beyond the network layer are a lot of other things that show up as being
useful to work on in order to allow more data to go through Bitcoin cheaper
and faster. Its still young software and I don't think its been bothered
with profilers or other speed measurements very often. Gavin started a
benchmark suite that never really saw uptake by any of the other
developers. So please expect a huge amount of benefits to happen in the
next years alone for throughput as its easy pickings for optimizations when
its not been done for years.</p>

<p>I would say that within a year the network would be safely able to handle
between 20 and 50 MB blocks.</p>

<p>Creating a Bitcoin that, on-chain, can grow and support more users will be
the thing that actually creates more value for the Bitcoin ecosystem.
So while our opponents are discussing how to distribute the money of the
rich differently, until they inevitably run out of money, we are working to
actually create new value to increase your wealth as well as ours.</p>

<p>Bitcoin has a bright future.</p>

</section>

<footer class="inlinefooter">
<span class="readMore">

<a href="../../../posts/Innovation - OnlineScaling/">Read full...</a>

</span>
<span class="pagedate">Posted <time datetime="2016-07-04T10:06:57Z" pubdate="pubdate">Mon 04 Jul 2016 10:06:57 AM Europe</time></span>


<nav class="tags">
Tags:

<a href="../../../tags/Bitcoin/" rel="tag">Bitcoin</a>

<a href="../../../tags/Community/" rel="tag">Community</a>

<a href="../../../tags/Mining/" rel="tag">Mining</a>

</nav>

</footer>
</article>
<article class="inlinepage">

<section class="inlineheader">
<header class="header">

<a href="../../../posts/Scaling Bitcoin/">Scaling Bitcoin</a>

</header>
</section>

<section class="inlinecontent">
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<p>One of the most talked about topics in 2016 when it comes to Bitcoin is the
lack of good plan for growing and scaling of the system into the future.</p>

<p>I found this curious as anyone that starts to depend on any system should
do at least some investigation on what kind of growth it can handle, and
if it can actually do what we want it to do, this year and 5 years or
longer into the future.</p>

<p>In this post I want to investigate what kind of scaling we can expect
Bitcoin to have and what we need to do to get more scaling out of the
system if it would not be enough.</p>

<h2 id="goals">Goals</h2>

<p>The number one reason that Bitcoin has value right now is its <em>promise</em>
that Bitcoin will be used and seen as useful by millions of people in the
not-so-far future.  Any money only has value when enough people think it
has value.  Any money only has value when it actually can be <em>used</em>. If
nobody accepts it for payments, the value will not be realized either.</p>

<p>So the number one goal is to allow millions of people to be able to use
Bitcoin in their day-to-day lives. Where 'use' is defined as making at
least one transaction a day. As any technology, we don't expect this load
to be available tomorrow, or this year because growth happens over time and
systems get build over time.</p>

<p>So lets have a goal of 50 million users sending one transaction a day using
the Bitcoin network. Not today but 5 year in the future.</p>

<p>Further goal is that for home-users the rate at which they can process
Bitcoin blocks should be at least twice the speed at which they get
created.  This means that if a system has no internet for an hour it would
take no more than half an hour at full speed to catch up.  Faster is
better, but slower than twice the creation speed is too slow.</p>

<h2 id="baseline">Baseline</h2>

<p><strong>or, what is the current theoretical level of support</strong></p>

<p>Bitcoin, in the form of various node-software implementations, has had
several years to mature. The leadership was not really focused on growth
very much of this basic layer as we can see from the amount of progress
that started happening <em>after</em> Bitcoin Classic and Bitcoin Unlimited
started competing. As usual, competition is good for the end-user and we
see some promise of future gains appear.</p>

<p>But lets take a look at what kind of transaction load we could support
today.</p>

<p>Last week <a href="http://forum.bitcoin.com">forum.bitcoin.com</a> published a
<a href="https://www.youtube.com/watch?time_continue=45&amp;v=vL8ZRYsLdoY">video</a> about
time it takes to download, fully validate and check 7 years, or 420000
blocks of Bitcoin history. From day on of Bitcoin. This is 75GB of data
which took 6 hours and 50 minutes to fully validate on moderate hardware.
It wasn't cheap hardware, but it was certainly not top-of-the-line or
server hardware.  In other words, it is a good baseline.</p>

<p>Taking a closer look at what was done in 6hours 50min</p>

<ul>
<li>since block
<a href="https://github.com/bitcoinclassic/bitcoinclassic/blob/1.1/src/chainparams.cpp#L154">295000</a>
till block 420000 (125000 blocks) each and every transaction signature has
been validated.</li>
<li>75GB was downloaded from Bitcoin peers around the world.</li>
<li>It build a UTXO database of 11 million transactions with 40 million
not yet spent Bitcoin addresses.  (see the RPC call gettxoutsetinfo).</li>
<li>The 125000 blocks contained 104847758 <a href="findTxCount.pl">transactions</a> which
have all been validated.  Thats 105 Million txs.</li>
</ul>

<p>We understand that this was all done with no tweaks to the settings. This
was a Classic 1.1.0 node (equivalent to Bitcoin Core 0.12.1)</p>

<h2 id="whatneedswork">What needs work?</h2>

<p>Lets take a look and compare our baseline to our goal. Most people would
like software to always get faster and better, but priorities matter and we
should look at which parts need attention first.</p>

<p>Our goal was that individual node needs to process in 24 hours about 50
million transactions.</p>

<p>We noticed that in the baseline check of 6h50 hours it actually
downloaded and stored and checked almost 105 million transactions.
Which leads to a daily rate of 368 million transactions being downloaded and
validated.</p>

<p>$$ TX_{day} = {{104847758 tx \over { 6 * 60 + 50 minutes}} * 24 * 60 minutes} = 368 million$$</p>

<p>This means that our 5-years-in-the-future goal of 50 million transactions
per day is already today not an issue for bandwidth and for CPU power. In
fact, out baseline system managed to go over it with over a factor of 7.</p>

<p>Today our baseline system could handle 7 times the volume that is the goal
5 years in the future!</p>

<p>Today, an individual Bitcoin node can download, store and validate 368 million
transactions a day. Thats many times the volume that has <em>ever</em> been sent
using Bitcoin.</p>

<h2 id="howdoiseethesystemscale">How do I see the system scale?</h2>

<h3 id="atypicalhome-node">A typical home-node</h3>

<p>A node that validates all blocks fully is needed in order to keep
everyone honest. It also gives me peace of mind in that if I trust my node,
I don't have to trust anyone else.  So I foresee that you will get small
communities to gather around full nodes.  You can let your family use it,
or maybe your football club or church will set one up just to support the
community.  Individuals will then make their phone-wallets have at least
one host they trust, which is the one from your community.</p>

<p>This preserves Bitcoins greatest assets, you don't have to trust banks or
governments. People trusting their local church or football club is much
more normal and common to do.</p>

<p>Such a node would have no need to keep the full history till block zero. It
would turn on pruning.  With todays price of hardware this does not mean it
would stop being able to serve historic blocks because it could easily hold
a month of blocks history. This does, however, mean we need to make the
software a bit smarter. See some <a href="../../../scaling/Pruning/">pruning</a> ideas.</p>

<p>Harddrive space is cheap today. A 3TB harddrive stores 75 years of Bitcoin
history at current block size.  But what if we start getting to our goal.
What kind of harddrive do we need?</p>

<p>The answer to that is that we don't need anything large at all. The idea
that we need to have a larger harddrive because blocks are bigger is a
misunderstanding. We should work on some <a href="../../../scaling/Pruning/">pruning</a> ideas
in order to scale the system without everyone having to invest in storage
space.</p>

<p>The last of the big components for our hone node is internet connectivity.
To reach our goal we need to be able to download 50 million transactions at
about 300 bytes each in a 24 hours period.</p>

<p>$$ {50 000 000 * 300 \over {24 * 60 * 60}} = 173611 bytes/sec $$
  $$ {173611 \ over 8} = 22 Kbit/sec $$</p>

<p>Ideally we go twice as fast to make sure that the node can 'catch up' if it
were offline for some time. We may want to add some overhead for other
parts as well. But 22Kb is below the minimum internet speed that can be
acquired practically everywhere as the basic plan. 2Mb (100 times faster)
is practically available in all parts of the world. 2Gb which is 100,000
times faster than what we need to reach our plan in 5 years is available
in countries like Japan today.</p>

<p>Home nodes have absolutely nothing to fear from even a huge growth of
Bitcoin to about 50 million daily users, their hardware and internet will
cover them with no pains, especially in about 5 years when more software
optimizations may have been created.</p>

<p>Notice that there is no dependency on things like Moore's law here, no
hardware growth is needed to reach our goal.</p>

<h2 id="atypicaluser">A typical user</h2>

<p>A typical user is suggested to use a phone or hardware wallet.  The
actual requirements are really not a lot to be able to make payments safely
and fast if you use
<a href="http://bitcoinfactswiki.github.io/Scalability/#Simplified_payment_verification">SPV</a>
clients.</p>

<p>Current wallets are in need of some work, though. They are typically quite
greedy in using network to update the state of the wallet. While useful,
this is not wanted in many situations. When I'm abroad on an expensive
data-plan, for instance.</p>

<p>There is no need to do any communication with the network before creating a
transaction that pays a merchant. Only the actual payment itself needs to
be transferred to the Bitcoin network.</p>

<p>A typical user uses a phone. On the topic of scaling there is little to
nothing he has to do in order to continue working with on-chain scaling.</p>

<p>Usability and related topics need substantial amounts of work, though.</p>

<h2 id="atypicalminingnode">A typical mining node</h2>

<p>Miners need a full node. Where 'full' means that it validates all
transactions.  In addition to what a home-node needs, a miner also needs
a fast connection between miners and to have a fast way to broadcast his
blocks to other miners.</p>

<p>Just like with a typical home-node the amount of bandwidth and harddrive
and CPU speed are already today mostly sufficient for being part of the
network.</p>

<p>Additionally, the miner uses his node to create block templates. Which
means he takes a section of the pool of unconfirmed transactions and
creates a block based on that. This process has seen some optimizations
already, but more could be made.  For instance the getblocktemplate RPC
call checks the block it just created for validity before it returns it.
This check takes quite a lot of time and a simple solution would be to
decouple the returning of the block and the validation so the miner can
start mining optimistically over the check passing (it should pass in 100%
of the cases anyway).</p>

<p>The bigger the blocks get, the more data is returned and the system
currently uses JSON which is almost the worst type of data-container for
large binary data-blobs.  A simple replacement of the RPC interface with
something that just changes the communication format to be binary is
relatively easy to do (a month project, probably) and likely needed for
miners to not end up waiting to long on this.</p>

<p>In our baseline node we explained that it took 7 hours to fully sync a
brand new node from zero.  This will stop being the case when we scale up
to much bigger sizes.  It will start taking a substantial amount of time to
do the initial sync.  Yet, a miner requires a fully synced node.
Bitcoin Classic already has one big change there that will push down the
validation time substantially. It introduced dynamic checkpoints which
allow the node to skip validation of transaction data by assuming that
about a week worth of blocks will not be build on top of double-spend data.
This would remove the validation of 100s of millions of transactions for a
starting node.</p>

<p>Another suggestion for future Bitcoin clients meant for miners is that a
new node can be pointed to a known and trusted node.  The new node would
then receive the UTXO and all other details it needs to be up and running
quickly from this trusted node.  Which means that after downloading only a
couple of gigabytes you can have your new node up in 10 minutes.</p>

<p>The most important improvements for mining are various ways to ensure fast
download and upload of the actual new blocks.</p>

<p>First there is xthin, which is a way to make a 1MB block only cost 25KB to
send to all miners.  This scaling is linear in that a 10MB block will
likely be around 250KB to send.</p>

<p>Next to that is a technique I called "optimistic mining" which helps miners
by splitting the uploading of blocks into two parts. One is a super fast
notification of the new block. Just the block-header. A miner receiving
such a header validates it has valid proof of work and then can start
mining empty blocks on top.  When the full block has arrived and all
transactions are seen. All transactions in the mempool are updated to
account for the new block, and last, a new block template is created with
as many transactions as fit, only then does the miner start mining it.</p>

<p>A mining node has no need for either a <a href="../On%20Mining%20and%20Wallets">wallet in their
node</a> or to have a history of blocks on their
node, so they can turn on <a href="../../../scaling/Pruning/">pruning</a>.</p>

<p>Many of these techniques are already in development or planned to be
developed in the next year or so.  In order to reach our 50 million users
per day in 5 years most of these will be more than enough to make a miner
able to keep connected to the Bitcoin network without having to invest in a
high-end server for the Bitcoin node.</p>

<h2 id="conclusions">Conclusions</h2>

<p>The goal I tried to argue from is 50 million users per day. This goal is
a huge increase from today. But to make sure we do it properly, my goal is
set 5 years in the future.</p>

<p>Scaling Bitcoin-nodes is ultimately boring work with very little effort
needed because it turns out that a modern simple system can already scale
easy 10000 times higher than the current maximum allowed size.</p>

<p>Scaling the entire system takes a little more work, but mostly because
miners have not received a lot of new features that they would need in
order to make scaling safe for them.  Most of those features could be added
in a matter of months, with technologies like xthin blocks and optimistic
mining already well underway.</p>

<p>The conclusion that I have to draw is that the goal of 50M/day is not just
reachable, the timeline of 5 years is likely one that we will beat quite
easily.</p>

<p>Smart tricks like Lightning network are not mentioned at all in this
document because there is no need for them. Bitcoin can scale on-chain
quite easily with almost no risk. Ideas like Lightning are quite high risk
because there are so many unknowns.</p>

<p>By far the biggest problem with regards to scaling today is the protocol
limit of 1MB block size.  This should be removed as soon as possible.</p>

</section>

<footer class="inlinefooter">
<span class="readMore">

<a href="../../../posts/Scaling Bitcoin/">Read full...</a>

</span>
<span class="pagedate">Posted <time datetime="2016-07-11T11:22:31Z" pubdate="pubdate">Mon 11 Jul 2016 11:22:31 AM Europe</time></span>


<nav class="tags">
Tags:

<a href="../../../tags/Bitcoin/" rel="tag">Bitcoin</a>

<a href="../../../tags/Mining/" rel="tag">Mining</a>

</nav>

</footer>
</article>


</section>







</div>

<footer id="footer" class="pagefooter" role="contentinfo">

<nav id="pageinfo">





<div class="copyrightinfo">
Copyright &copy; 2016 Tom Zander &lt;tomz@freedommail.ch&gt;</br>
Content licensed under the <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC by-sa</a>
</div>

<div class="pagedate">
Last edited <time datetime="2016-07-11T13:23:44Z">Mon 11 Jul 2016 01:23:44 PM Europe</time>
</div>

</nav>


</footer>
</article>

</body>
</html>
